# Defence

## File Injections

### Που τις συναντήσαμε;
Όπως είναι φυσιολογικό τις ευπάθειες για τις επιθέσεις αυτές τις συναντήσαμε στις σελίδες όπου ο εγγεγραμμένος
στο μάθημα μπορεί να ανεβάσει κάποιο αρχείο. Πιο συγκεκριμένα βρέθηκαν δύο τέτοια σημεία. Το ένα, βρισκόταν στην σελίδα
όπου κάποιος μαθητής μπορεί να ανεβάσει κάποιο αρχεία για κάποια εργασία που έχει δημιουργηθεί. Το δεύτερο ήταν στην
ανταλλαγή αρχείων** όπου φυσιολογικό μπορεί κάποιος να ανεβάσει αρχεία.

### Τι μπορεί να συμβεί
Μέσω της ευπάθειας αυτής στην περίπτωση που κάποιος ανεβάσει κάποιο αρχείο παρόλο που μετονομάζεται(σύμφωνα με τα στοιχεία
του χρήστη) και αποθηκεύεται σε έναν φάκελο με τυχαίο όνομα. Ο επιτιθέμενος μπορεί να πλοηγηθεί παρόλα αυτά στο αρχείο που 
ανέβασε με αποτέλεσμα να εκτελεστεί ο κώδικα που θα βρίσκεται στο ανεβασμένο αρχείο του αποκτώντας ακόμα και ένα shell στο
μηχάνημα που τρέχει η εφαρμογή του e-class.

### Πως το αντιμετωπίσαμε
Δυστυχώς, το μόνο που πραγματοποιήσαμε είναι να κάνουμε ένα απλό check στο extension του αρχείου και να μην το επιτρέπουμε
να ανέβει αν βρίσκεται το extension μέσα ένα blacklist από κάποια αρχεία.

### Τι θα μπορούσαμε να κάνουμε ακόμα
* Αρχικά θα μπούσαμε να τσεκάρουμε με καλύτερο τρόπο το είδος του αρχείου που ανεβάζει ο χρήστης (Με check του mime-type, 
  vulnerable but still better).
* Ακόμα θα μπορούσαμε να περιορίσουμε τα permission στον parent folder που περιέχει όλους του φακέλου με τυχαία ονόματα που
  δημιουργούνται και περιέχουν τα ανεβασμένα αρχεία.
* Το γεγονός ότι το όνομα του αρχείου που αποθηκεύεται προκύπτει από τα στοιχεία του χρήστη είναι και αυτό ένα στοιχείο που
θα μπορούσε να αποβεί μοιραίο και επομένως να αλλάξει.

** Λόγω λάθος μας, έγινε  αλλαγή στο αρχείο που αφερόταν στο ανέβασμα αρχείου στις "Ομάδες Χρηστών" στο μάθημα που δημιουργείται και
όχι στο αρχείου που αναφερόταν στην "Ανταλλαγή αρχείων" όπως ανέφερε η εκφώνηση.

## SQLi

### Που τις συναντήσαμε;
Δεδομένου ότι η εφαρμογή μας, επικοινωνεί με μία sql βάση δεδομένων, σε πλήθος σελίδων γίνονται κάποια sql ερωτήματα, είτε
για την αποθήκευση πληροφορίας, είτε για την ανάκτηση πληροφορίες. Σε αρκετά από αυτά τα ερωτήματα, χρησιμοποιούνται μεταβλητές
που το περιεχόμενο τους ορίζεται από τον χρήστη. Ένας κακόβουλος χρήστης λοιπόν, μπορεί να εισάγει στις μεταβλητές αυτές κάποια 
συμβολοσειρά που να έχει αρνητικά αποτελέσματα.

### Τι μπορεί να συμβεί
Έχοντας τη δυνατότητα να παραποιήσει τα ερωτήματα με όποιον τρόπο επιθυμεί, ο επιτιθέμενος, καταφέρνει να έχει πρόσβαση σε δεδομένα
τα οποία δε θα επιθυμούσαμε σε διαφορετική περίπτωση να έχει πρόσβαση, ενώ σε ακόμα χειρότερη περίπτωση να τροποποιήσει ήδη 
αποθηκευμένα δεδομένα.

### Πως το αντιμετωπίσαμε
Αρχικά μπορούμε να πούμε πως στην εφαρμογή υπήρχε ένα επίπεδο προστασίας για SQLi μέσω της συνάρτησης mysql_real_escape_string
η οποία αποφεύγει τους ειδικούς χαρακτήρες που χρησιμοποιούνται σε ένα SQL ερώτημα. Παρόλα αυτά σε κάποια σημεία βεβαιωθήκαμε πως
όταν σκοπός του χρήστη ήταν να προσδώσει έναν αριθμό να επιβεβαιώσουμε πως η είσοδος ήταν αριθμός μέσω της `intval()` ενώ ακόμη 
 αρκετά ερωτήματα τα μετατρέψαμε να γίνονται μέσω prepare statement ώστε να εξασφαλίσουμε ποιο είναι το ερώτημα και ποια τα δεδομένα
που εισάγει ο χρήστης.

## XSS

### Τι είναι;
Το Cross-Site Scripting είναι μία επίθεση που προσπαθεί να προσθέσει εκτελέσιμο κώδικα (javascript ή HTML) σε κάποιο site εκμεταλλευόμενο διάφορες ευπάθειες που μπορεί να έχει (πεδία φόρμας, παράμετροι URL κτλ.) Αυτό ο κώδικας μπορεί να τρέξει απο τον browser κάποιου ανυποψίαστου χρήστη για την υποκλοπή δεδομένων η και την εκτέλεση ανεπιθύμητων ενεργειών.

### Τρόποι αποφυγής.
Για την αποφυγή τέτοιων επιθέσεων οποιοδήποτε input κάποιου χρήστη δε θα πρέπει να μπορεί να ερμηνευτεί ως HTML ή Javascript κώδικας που ο browser μπορεί να εκτελέσει. Γιαυτό τον λόγο αποφασίσαμε να χρησιμοποιήσουμε τη συνάρτηση `htmlspecialchars` της php έτσι ώστε να γίνουν escape τυχόν ειδικοί χαρακτήρες της HTML και να μην είναι δυνατή η εκτέλεση.

### Που το συναντήσαμε.
Τα σημεία που συναντήσαμε τις ευπάθειες ήταν κυρίως σε πεδία φορμών όπως στη "εγγραφή νέου χρήστη, αλλαγή των στοιχείων του προφίλ του χρήστη κ.α", στο κομμάτι της τηλεσυνεργασίας και στο φόρουμ του μαθήματος. Τέλος, πολλές ευπάθειες βρήκαμε και σε παραμέτρους URL.

## CSRF

### Τι είναι;
Το CSRF (Cross-Site Request Forgery) είναι μία επίθεση που προσπαθεί να κάνει το θύμα να εκτελέσει ανεπιθύμητες ενέργειες στην εφαρμογή που είναι πιστοποιημένος. Συνήθως, απαιτεί την αποστολή κάποιου κακόβουλου συνδέσμου στο θύμα το οποίο αν το επισκεφτεί, ενώ ταυτόχρονα είναι πιστοποιημένος στην εφαρμογή, θα καταλήξει να γίνει κάποιο ανεπιθύμητο request σε αυτή.

### Τρόποι αποφυγής.
Η βέλτιστη λύση για αποφυγή τέτοιων επιθέσεων είναι η υλοποίηση Tokens, δηλαδή τυχαία strings. Αυτά τα tokens δημιουργούνται όταν ο χρήστης ζητάει την αυθεντική σελίδα. Αυτά προστίθενται ως παράμετροι της φορμας η του URL ενώ ταυτόχρονα προστίθενται στο SESSION του χρήστη. Έτσι, όταν ο χρήστης πατήσει τον link, θα δημιουργηθεί ένα token το οποίο θα συγκριθεί με αυτό του SESSION και αν είναι ίσα θα εγκριθεί το request.
Για την παραπάνω διαδικασία υλοποιήσαμε κάποιες συναρτήσεις στο αρχείο /openeclass/include/lib/main.lib.php.<br>
`csrf_token()`: την οποία χρησιμοποιήσαμε στο κομμάτι του HTML κώδικα κατά την υποβολή μίας φόρμας.<br>
`validate_token()`: η οποία ελέγχει αν το παρών token είναι ίσο με το `SESSION['token']`<br>
`error_msg`: Που εκτυπώνεται σε περίπτωση σε περίπτωση που δεν περάσει το validation.<br>

### Που το συνατήσαμε.
Τα σημεία που συναντήσαμε τις ευπάθειες αυτές ήταν αρκετά. Επικεντρωθήκαμε στις φόρμες που μπορούν να εκτελεστούν απο κάποιον administrator καθώς απο αυτές μπορεί να δημιουργηθεί η μεγαλύτερη ζημία στο site. Επιπλέον, φτιάξαμε και τις σελίδες χρηστών που μπορούν να δεχτούν csrf attack όπως "Αλλαγή στοιχείων του προφίλ, υποβολή εργασίας".

### Τι θα μπορούσαμε να κάνουμε ακόμα.
Επίσης για μεγαλύτερη ασφάλεια θα μπορούσα να δημιουργούμε ενα ξεχωριστό token ανά φόρμα που υποβάλλεται και να ακούγεται η αντίστοιχη διαδικασία.
